### 我的工程公理
```
几个月前，我在一次演讲中分享了我的个人工程公理列表——这些年来，我认为在编写代码、构建东西时通常是正确和有用的，并与他人合作。

Axiom 是一个花哨的词，但是从词源堆栈中弹出几层，我们巧妙地到达了古希腊词ἀξίωμα，或“被认为合适或有价值的东西”。我喜欢这样，并且认为列表中的每个项目至少值得考虑。

当然，它们是我的工程公理——根据我自己的经验，我认为它们是有用的。你的经历可能会有所不同。也许您已经知道零终止，或者拥有比剪刀更好的工具来消除程序中的错误。

无论如何，我认为在这里分享列表会很有趣，并进行一些简短的说明。有些事情并不令人惊讶，但希望其他事情会产生一些挑衅性的想法和/或有趣的分歧。
```

1.变化是不变的。
这个不应该有太大的争议。几乎一切都在变化，包括变化速度本身。我们不仅需要承认我们应对变化的能力至关重要，而且我们做得如何（时间、成本、质量、可靠性）通常是我们竞争力的一个方面。

2. 你的产品是资产，但代码是负债。
您的产品解决了客户的问题，因此是您的资产。代码本身就是创建资产的成本。你拥有的代码越多，就越需要阅读、测试、更改和理解。当您考虑公理 1 时，这一点尤其重要。保守地接受新代码（以及对外部代码的依赖）。最好的代码是您不必编写的代码。

3. 复制比过早抽象成本更低。
除非你有高度的信心，你的抽象会为自己付出代价，因为它解决了你确实有的一个真实的、抽象的问题，否则不要这样做。等待并了解更多信息。在那之前，重复代码可以帮助避免依赖，这本身使得代码更容易独立更改或删除。过早的抽象会通过依赖和间接产生复杂性，并可能成为您响应变化能力的瓶颈。

4. 代码应该易于删除。
编写可移动的代码，这在很大程度上与说“解耦”相同。可以肯定的是，并非所有代码都需要类似地可移除，但最大限度地减少依赖关系，通过明确定义的接口具有清晰的边界，并且具有深思熟虑的整体系统设计允许更轻松地移除/更改部分。我曾经听说有人使用“代码花费”这个表达方式来替代“编写代码”，我很喜欢。我喜欢删除代码正在降低未来成本的暗示。

5. 现有代码产生强大影响。
它在那里的事实表明它是正确和必要的。希望是这样，但并非总是如此。我们需要保持改变它的信心，以及推理我们是否应该这样做的能力。不要让代码本身的存在让人怀疑它不能被删除。根据公理 4，它应该很容易移除，并且系统设计应该足以让我们了解我们是否仍然需要它。

6. 意外的复杂性是最大的风险之一。
意外复杂性是可以避免的复杂性，它的发生是由于设计不佳、决策错误以及没有优先考虑系统内适当的简单级别。如果简单不是目标，那么随着系统的增长，意外的复杂性更可能发生，并且会逐渐对几乎所有事情产生负面影响，从改变系统到甚至能够理解它。2006 年的论文Out of the Tar Pit在这个主题上值得一读。

7. 糟糕的个人技能可能会影响技术卓越。
除非您完全独自工作，否则重要的不仅仅是您解决技术问题、编写好代码等的能力。相反，如果你让周围的人不开心、效率低下，它们就更不重要了。就像学习写好代码一样，你也必须学会“对人”。同理心是其中很重要的一部分，因为认识到人们是不同的——关心他人、理解他人、帮助他人、自己寻求帮助、友善。成为其他人想与之共事的工程师。

8. 你不是你的代码。善待编码者，而不是代码。
代码只是捕捉我们认为我们知道的东西的时间。不是你。你可能已经写了它，但从那一刻起（即使是 3 分钟前）你已经长大了，但代码却没有。关于代码的对话，无论好坏，都不应该是私人的。保持专业。谈论代码或问题，但不要谈论编写代码的人。使用“我们”而不是“你”。有时我试着假装我写了别人写的代码，这有助于我避免不小心听起来很私人。

9. 以尊重和耐心对待比你了解少的人。
我们都从某个地方开始，当你被那些希望你成功的耐心的人而不是那些让你觉得自己不属于自己的人包围时，旅程会更加快乐。如果您对此感到困惑，那么记住新手程序员几乎可以肯定比您做得更好 - 也许他们精通另一种语言，或者烹饪惊人，或者从事一项运动，这可能会有所帮助。想象一下自己扮演相反的角色。你希望他们如何对待你，这个新手？再次：成为其他人想与之共事的工程师。

10.唯一真正的权威来自知识，而不是来自职位。
对问题、领域、客户的了解和理解都远比名片上的前三个字母重要得多。即使它确实有水印。从首要原则了解事物的运作方式，建立扎实的理解，权威就会随之而来。

11.教学是变相学习的一种形式。
如果你认为你知道什么，试着教它。通常，试图向别人解释你所知道的事情的行为本身就会迫使你更清楚地把自己的想法形式化。把事情写下来似乎也有类似的效果。我已经数不清有多少次我开始解释某事，却发现我并不像我想象的那样完全理解它。

12. 提升你周围人的技能，而不仅仅是你自己。
一个伟大的团队永远不会因为一个了不起的人而变得伟大。这是一个伟大的团队，因为每个人都互相挑战，每个人都一起成长。当你学到一些很酷的东西时，分享它——帮助你周围的人变得更好。当他们这样做时，每个人都会受益，没有人会落伍。它也更有趣。次要好处：公理 11。

13. 等待的时间越长，你就会知道的越多。
我仍在学习这一点，并努力避免我几乎默认的快速决定的愿望。事实是，你拖延非必要决定的时间越长，你在做出决定时就必须依靠的信息越多。当然，你不能总是拖延一个决定，但通常你可以，至少你应该考虑一下现在不知道答案是否真的可以。

14. 一个好的类型系统值得它的重量加上一些。
在我的职业生涯中通过各种静态和动态语言来回走动，我目前认为一个好的类型系统值得它的开销。一个好的类型系统不应该带来那么多开销。如果类型系统设计得好，它几乎可以感觉像是一种动态语言（通过推理和流分析等功能），同时消除了编译器可以比你更好更快地处理的一整类问题。像 Rust 中的所有权这样的发展是一个很好的例子，它比人们几年前想象的更进一步。

15. 合适的团队胜过一切。
拥有一个只想一起工作并建立伟大事物的团队可以使许多其他问题更容易处理。这里的“正确”这个词是高度主观的和上下文相关的，但至少有趣的是，同理心、尊重和友谊一直是我参与过的伟大团队的反复出现的元素。

16.坚持无聊的技术，除非有充分的理由不这样做。
无聊的技术通常更老，更容易理解。在如何有效地使用它、更好地理解它的故障模式以及如何最好地应用它方面更容易找到人员和资源。我真的很喜欢 Dan McKinley 的创新代币理念。你只会得到 3 个。使用它们来采用或构建全新的东西——理想情况下，这些东西会让你在核心能力方面做得更好——但是超过 3 个，永远无法达到稳定/成熟的风险开始增加。

17. 拥有尽可能小的团队，但不能更小。小心地种植它。
一个著名报价的戏剧，你的里程可能会有所不同。到目前为止，在我的职业生涯中，我确实看到小型团队比大型团队更有效。当然，要找到一个平衡点，这取决于你要解决的问题的规模和复杂性。也就是说，较小的团队受益于更少的沟通开销、更少的错误沟通空间以及更多的空间让每个人的声音都能被听到。在一个较小的团队中，它也感觉更加个人化，我感到更有责任感，我喜欢这样。

18. 休息。
我很高兴看到“无时无刻工作以取得成功”的态度逐渐去性别化，人们对心理健康和福祉的关注度大大提高。当你不休息时，很难感到快乐，而当你不快乐时，更难做到最好。为了达到最佳状态，我们必须花时间不工作。我喜欢将休息视为我工作能力的关键部分，就像体育锻炼一样。

19. 在你至少想到一个解决方案之前，不要选择一个解决方案。
当那个东西在你的脑海中咔哒一声，你意识到你找到了解决问题的方法时，它既诱人又令人兴奋。也许有一个很酷的微不足道的问题，而且真的没有什么可做的了。但是，如果问题不是微不足道或重要的，那么值得考虑的是，可能还有其他您根本没有想到的解决方案。

为了避免在从没有解决方案到解决方案的兴奋中迷失方向，而只是按照你脑海中浮现的第一件事去做，试着至少再想一个。试图找到第二种解决方案通常会迫使您以不同的方式思考，一旦您有两个解决方案，您将被迫考虑权衡以选择一个。这种对比鲜明的权衡通常也有助于更清楚地描述问题。

20. 有自己的观点，但要避免以让别人相信你不会改变它们的方式表达它们。
表达我们的信念和观点很重要，我们都应该有这样做的空间。然而，在分享观点和听起来好像你在分享一个不可动摇的事实之间有一条很好的界限。在一个团队中，每个人都觉得他们可以挑战一种观点并有可能改变它，或者他们自己的观点，这是非常健康的。

我收到的一条很好的建议有助于解决这个问题，那就是表达你的信念以及你的确定程度。“我 95% 确信使用 Visual Basic 是个坏主意。” 即使是 95%，这既是一个让人们质疑信念并建立对话的机会，也是一个让你在学习新信息时简单地修改你的确定性的机会。

21. 可以说“我不知道”或“我需要研究一下才能得到答案”。
老实说，我们都不知道我们在做什么。你做？好吧，我没有。我们的行业发展迅速，虽然有很多新旧事物，但也有大量新事物。我们每天都在学习，没有答案是绝对可以的。我们的价值不是我们无所不知的能力，而是我们学习、发现、回答这些问题和创造新问题的能力。

当有人告诉我“我不知道”时，我很兴奋，因为现在我知道我们可以一起探索这个问题，并且都可以学到一些东西。不要隐藏它，好像你是唯一一个不知道的人。通常没有人知道，但你的诚实让每个人都可以公开加入并一起工作。

22. 编写一次性代码来探索问题空间被低估了。
几次完全错误并重新开始可能比第一次尝试正确解决它更快。有时，探索问题的最佳方法是非常接近它并尽可能多地学习。

也许您还没有真正理解问题空间，但是通过尝试一些事情，您可以发现有关设计的高级对话或阅读文档会完全错过的东西。可以自由地犯尽可能多的错误并在最后扔掉它，你可以很快学习。

23. 谨慎管理状态。
每个程序都有状态，但是如何管理该状态会产生很大的不同。状态管理不善是导致整个系统复杂性的一个巨大因素，并且经常发生是因为在它发展成为问题的更糟糕版本之前没有足够早地考虑它。

有许多不同的策略可以提供帮助，从在给定环境中处理状态的特定方法，到使用函数式语言和/或方法来围绕状态如何更改创建更严格的约束。无论您做什么，都要仔细考虑系统中的状态如何变化。

24. 一切都是取舍。
几乎在你做出的每一个决定中，你都在有意或无意地用一件事换另一件事。有时权衡是显而易见的，但有时它们与我们眼前所见的事物相距甚远。如果它们不是立即显而易见的，请始终考虑权衡可能在哪里。

一个很好的例子是围棋。Go 有一个相当糟糕的类型系统（目前），而且它是一种很小的语言。有什么取舍？由于它的大小和对花哨的支持有限，我的代码看起来像你的代码，而且我阅读其他人的代码时“哇，我需要尽快重写这个”比以往任何时候都少，而且我感觉效率更高。总有一个权衡的地方。寻找它，您将能够做出更好的决定。

25. 一个好的设计是你可以在不改变太多代码的情况下改变你的想法。
根据公理 1，变化是恒定的。这意味着我们需要很好地处理不断变化的条件才能取得成功——不仅是发生在我们周围并带我们顺风顺水的外部变化，还有来自支点、新功能、扩展挑战等的内部变化。

一个好的系统设计应该尽可能地适应我们改变处理问题的方式的需要，而不是强迫我们从头开始。换句话说，我们必须更改或删除的部分越少（根据公理 4，这应该很容易），我们就可以更快地面对变化；设计越好。
